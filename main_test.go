package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"gopkg.in/urfave/cli.v1"
	"io"
	"log"
	"os"
	"regexp"
	"strings"
	"testing"
	"unicode"
)

var testHelpMessages = map[string]string{
	"general": `
		NAME:
           vulnscan - iOS and MacOS vulnerability scanner
        USAGE:
           [global options] command [command options] [arguments...]
        VERSION:
           0.0.1
        AUTHOR:
           Vulnscan Team <vulnscan@simplycubed.com>
        COMMANDS:
             lookup, l  itunes app lookup
             scan, s    scans source directory and binary file security scan
             help, h    Shows a list of commands or help for one command
        GLOBAL OPTIONS:
           --help, -h     show help
           --version, -v  print the version
        COPYRIGHT:
           (c) 2019 SimplyCubed, LLC - Mozilla Public License 2.0
	`,
	"lookup": `
		NAME: 
			lookup - itunes app lookup
		USAGE: 
			lookup [command options] [arguments...]
		OPTIONS:
			--app value, -a value      itunes app/bundle ID (i.e. com.easilydo.mail)
			--country value, -c value  itunes country ID (i.e. us, jp) (default: "us")
	`,
	"scan": `
		NAME: 
			scan - scans source directory and binary file security scan
        USAGE: 
		    scan [command options] [arguments...]
        OPTIONS: 
			--binary value, -b value  Full path to binary (ipa) file
            --source value, -s value  Full path to source code directory (default: "/private/var/folders/s5/4x10j_y95835_y91yd8jllvm0000gn/T")
	`,
}


// Helper function to get rid from spaces comparing strings
func stripSpaces(s string)string {
	return strings.Map(func(r rune) rune {
		if unicode.IsSpace(r) {
			return -1
		}
		return r
	}, s)
}

func TestHelp(t *testing.T) {
	// We need a cli context to create help messages.
	// As we need to create the context before hacking the stdout, we wrap it with a lambda
	ctx := func()*cli.Context {
		a := getApp()
		a.Setup()
		set := flag.NewFlagSet(a.Name, flag.ContinueOnError)
		return cli.NewContext(a, set, nil)
	}

	// We need a set of commands to generate help messages
	commands := map[string]func(){
		"general": func(){ _ = cli.ShowAppHelp(ctx()) },
		"lookup": func(){ _ = cli.ShowCommandHelp(ctx(), "lookup") },
		"scan": func(){ _ = cli.ShowCommandHelp(ctx(), "scan") },
	}


	// This lambda pipes the stdout to a string so we can read the generated help message. It returns an
	// error if the help message generated by the check function and the test string differ
	checkHelp := func(key, test string, check func()) error {
		// Let's hack the stdout to get the help message captured
		old := os.Stdout
		r, w, _ := os.Pipe()
		os.Stdout = w

		// Use a goroutine so printing can't block indefinitely
		outC := make(chan string)
		go func() {
			var buf bytes.Buffer
			_, _ = io.Copy(&buf, r)
			outC <- buf.String()
		}()

		// Generate the help message
		check()

		// Collect the results (the regex is needed to remove some noise generated by the context)
		_ = w.Close()
		os.Stdout = old
		out := regexp.MustCompile(`(___\w+)`).ReplaceAllString(<-outC, "")

		// Check for the error
		if stripSpaces(out) != stripSpaces(test) {
			return errors.New(fmt.Sprintf(
				"%s help message differs from expected:\nFound:\n %s\nExpected:\n %s", key, out, test))
		}
		return nil
	}

	// Run the tests and fail if we get an error
	for _, k := range []string{"general", "lookup", "scan"} {
		if err := checkHelp(k, testHelpMessages[k], commands[k]); err != nil {
			t.Errorf(err.Error())
		}
	}
}

func TestPrintItunesResults(t *testing.T) {
	r, w, _ := os.Pipe()
	log.SetOutput(w)
	// Use a goroutine so printing can't block indefinitely
	outC := make(chan string)
	go func() {
		var buf bytes.Buffer
		_, _ = io.Copy(&buf, r)
		outC <- buf.String()
	}()
	printiTunesResults("com.easilydo.mail", "us")
	_ = w.Close()
	log.SetOutput(os.Stdout)
	out := <-outC
	var messages strings.Builder
	for _, sps := range strings.Split(out, "\n") {
		if len(sps) > 1 {
			messages.WriteString(strings.Join(strings.Split(sps, " ")[2:], " "))
			messages.WriteString(" ")
		}
	}
	if msg, testMsg := messages.String(),
		"Fetching Details from App Store: com.easilydo.mail Total Results: 1 Title: " +
		"Email - Edison Mail URL: https://apps.apple.com/us/app/email-edison-mail/id922793622?uo=4";
	stripSpaces(msg) != stripSpaces(testMsg) {
		t.Errorf("Error printing itunes result, expected: %s, got: %s", testMsg, msg)
	}
}

